"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const moment = require("moment");
const path = require("path");
class ColoredLogger {
    constructor() {
        this.colors = {
            Reset: '\x1b[0m',
            Bright: '\x1b[1m',
            Dim: '\x1b[2m',
            Underscore: '\x1b[4m',
            Blink: '\x1b[5m',
            Reverse: '\x1b[7m',
            Hidden: '\x1b[8m',
            FgBlack: '\x1b[30m',
            FgRed: '\x1b[31m',
            FgGreen: '\x1b[32m',
            FgYellow: '\x1b[33m',
            FgBlue: '\x1b[34m',
            FgMagenta: '\x1b[35m',
            FgCyan: '\x1b[36m',
            FgWhite: '\x1b[37m',
            BgBlack: '\x1b[40m',
            BgRed: '\x1b[41m',
            BgGreen: '\x1b[42m',
            BgYellow: '\x1b[43m',
            BgBlue: '\x1b[44m',
            BgMagenta: '\x1b[45m',
            BgCyan: '\x1b[46m',
            BgWhite: '\x1b[47m'
        };
    }
    success(text) {
        this.infoParamsColor(`{}`, { color: this.colors.FgGreen, param: text });
    }
    info(text) {
        console.log(text);
    }
    infoParams(text, ...params) {
        const map = params.map(e => ({
            color: this.colors.FgCyan,
            param: e
        }));
        this.infoParamsColor(text, ...map);
    }
    infoParamsColor(text, ...params) {
        let i = 0;
        text.replace("{}", (substring, ...args) => {
            const param = params[i++];
            return `${param.color}${param.param}${this.colors.Reset}`;
        });
        this.info(text);
    }
}
exports.ColoredLogger = ColoredLogger;
class CommonDriver {
    constructor(dbRunner, migrationTable = 'migrations') {
        if (!dbRunner) {
            throw Error(`dbRunner can't be null`);
        }
        this.dbRunner = dbRunner;
        const tName = migrationTable.toLocaleLowerCase();
        if (tName !== migrationTable) {
            throw Error(`Migration table ${migrationTable} can't contain upper case`);
        }
        this.migrationTable = tName;
    }
    getSeparator() {
        return () => '?';
    }
    getDbMigrations() {
        return `select * from ${this.migrationTable}`;
    }
    removeAllMigrations() {
        return `update ${this.migrationTable} set error_if_happened = null where error_if_happened is not null`;
    }
    getFailedMigrations() {
        return `select * from ${this.migrationTable} where error_if_happened is not null`;
    }
    markExecuted() {
        const separator = this.getSeparator();
        return `insert into ${this.migrationTable} (name, created, error_if_happened) values (${separator()}, ${separator()}, ${separator()})`;
    }
    createUniqueTableIndex() {
        return `CREATE UNIQUE INDEX migrations_name_uindex ON ${this.migrationTable} (name)`;
    }
    query(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.readQuery(sql, params);
            return res.error;
        });
    }
    executeMultipleStatements(sql) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.query(sql, []);
        });
    }
    extractError(e) {
        if (e) {
            if (e.message) {
                return e.message;
            }
            else {
                return 'Unknown error';
            }
        }
        else {
            return null;
        }
    }
}
exports.CommonDriver = CommonDriver;
class PsqlDriver extends CommonDriver {
    isInitedSql() {
        return `SELECT 1 FROM information_schema.tables WHERE table_name = '${this.migrationTable}'`;
    }
    getSeparator() {
        let i = 0;
        return () => {
            i++;
            return `$${i}`;
        };
    }
    createTableSql() {
        return `CREATE TABLE ${this.migrationTable}` +
            `(` +
            `    id bigserial PRIMARY KEY ,` +
            `    name VARCHAR(128) NOT NULL,` +
            `    run_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    error_if_happened text` +
            `)`;
    }
    readQuery(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.dbRunner.query(sql, params, (err, result) => {
                    const newVar = {
                        error: this.extractError(err),
                        rows: result ? result.rows : [],
                    };
                    resolve(newVar);
                });
            });
        });
    }
}
exports.PsqlDriver = PsqlDriver;
class SQLite3Driver extends CommonDriver {
    isInitedSql() {
        return `SELECT name FROM sqlite_master WHERE type='table' AND name='${this.migrationTable}'`;
    }
    query(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.dbRunner.run(sql, params, (error) => {
                    resolve(this.extractError(error));
                });
            });
        });
    }
    executeMultipleStatements(sql) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.dbRunner.exec(sql, (err) => {
                    resolve(this.extractError(err));
                });
            });
        });
    }
    readQuery(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.dbRunner.all(sql, params, (error, result) => {
                    resolve({ error: this.extractError(error), rows: result });
                });
            });
        });
    }
    createTableSql() {
        return `CREATE TABLE ${this.migrationTable}` +
            `(` +
            `    id INTEGER  NOT NULL PRIMARY KEY AUTOINCREMENT ,` +
            `    name VARCHAR(128) NOT NULL,` +
            `    run_on DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    created DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    error_if_happened text` +
            `)`;
    }
}
exports.SQLite3Driver = SQLite3Driver;
class MysqlDriver extends CommonDriver {
    isInitedSql() {
        return `SHOW TABLES LIKE '${this.migrationTable}'`;
    }
    createTableSql() {
        return `CREATE TABLE ${this.migrationTable}` +
            `(` +
            `    id INT PRIMARY KEY AUTO_INCREMENT,` +
            `    name VARCHAR(128) NOT NULL,` +
            `    run_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,` +
            `    error_if_happened LONGTEXT` +
            `)`;
    }
    readQuery(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.dbRunner.query(sql, params, (error, result, fields) => {
                    resolve({ error: this.extractError(error), rows: result });
                });
            });
        });
    }
}
exports.MysqlDriver = MysqlDriver;
class CommandsRunner {
    constructor({ directoryWithScripts, dateFormat = 'YYYYMMDDHHmm', driver, logger = new ColoredLogger() }) {
        this.driver = driver;
        this.logger = logger;
        this.directoryWithScripts = directoryWithScripts;
        this.dateFormat = dateFormat;
        this.commands = {
            init: {
                description: 'Initialized database for migrations',
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.doInit();
                }),
                skipInit: true,
            },
            fake: {
                description: `Fakes the migrations, marks that files in ${this.directoryWithScripts} are executed successfully`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.fakeAllScripts();
                })
            },
            list: {
                description: `Show all unapplied migrations from ${this.directoryWithScripts}`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.printNewMigrations();
                })
            },
            migrate: {
                description: `Installs all new updates from ${this.directoryWithScripts}`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.findAndRunMigrations(false);
                })
            },
            forceMigrate: {
                description: `Installs all new updates from ${this.directoryWithScripts}. If one migration fails it goes to another one.`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield yield this.findAndRunMigrations(true);
                })
            },
            resolve: {
                description: `Marks all failed migrations as resolved`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.resolveAllMigrations();
                })
            },
            getFailed: {
                description: `Show all failed migrations`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.getFailedMigrations();
                })
            },
            help: {
                description: `Prints help`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    this.printHelp();
                }),
                skipInit: true,
            }
        };
    }
    runSql(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`runSql ${sql} :${params.join(',')}`);
            const result = yield this.driver.query(sql, params);
            if (result) {
                throw Error(result);
            }
        });
    }
    readSql(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`readSql ${sql} :${params.join(',')}`);
            const result = yield this.driver.readQuery(sql, params);
            if (result.error) {
                throw Error(result.error);
            }
            return result.rows;
        });
    }
    checkIfExists() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info('Checking if migration table exists');
            const result = yield this.readSql(this.driver.isInitedSql(), []);
            const isExists = result.length > 0;
            this.logger.info(isExists ? 'Migration table exists' : `Migration table doesn't exist`);
            return isExists;
        });
    }
    doInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.checkIfExists();
            if (!exists) {
                this.logger.info(`Creating migration table...`);
                yield this.runSql(this.driver.createTableSql(), []);
                yield this.runSql(this.driver.createUniqueTableIndex(), []);
                this.logger.success('DB has been successfully initialized');
            }
            else {
                this.logger.info('Db already exists');
            }
        });
    }
    getScriptStr(script) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.directoryWithScripts, script);
            return new Promise((resolve, reject) => {
                fs.readFile(filePath, { encoding: 'utf-8' }, (err, data) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    }
    getFilesMigrations(exclude) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                fs.readdir(this.directoryWithScripts, (err, files) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        if (exclude) {
                            files = files.filter(e => exclude.findIndex(f => f.name === e) < 0);
                        }
                        let result = [];
                        files.forEach(e => result.push({ name: e, created: moment(e, this.dateFormat).toDate() }));
                        result =
                            result.sort((a, b) => a.created.getTime() - b.created.getTime());
                        resolve(result);
                    }
                });
            });
        });
    }
    runScript(fileName, created, failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = yield this.getScriptStr(fileName);
            this.logger.infoParams('Executing {} ...', fileName);
            const error = yield this.driver.executeMultipleStatements(query);
            yield this.markExecuted(fileName, created, error);
            if (error && !failSilently) {
                throw Error(error);
            }
        });
    }
    markExecuted(fileName, created, migrationErr) {
        return __awaiter(this, void 0, void 0, function* () {
            if (migrationErr) {
                this.logger.infoParamsColor('Migration {} failed with error {}', { param: fileName, color: this.logger.colors.FgCyan }, { param: migrationErr, color: this.logger.colors.FgRed });
            }
            else {
                this.logger.infoParams('Migration {} succeeded', fileName);
            }
            yield this.runSql(this.driver.markExecuted(), [fileName, created, migrationErr]);
        });
    }
    findNewMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const completedMigrations = yield this.getCompletedMigrations(failSilently);
            return yield this.getFilesMigrations(completedMigrations);
        });
    }
    getDbMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.readSql(this.driver.getDbMigrations(), []);
        });
    }
    getCompletedMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getDbMigrations();
            if (!failSilently) {
                res.forEach(r => {
                    if (r.error_if_happened) {
                        throw Error(`Can't start migrations while having a failed one. Run 'resolve' first. Error details: \n${JSON.stringify(r)}`);
                    }
                });
            }
            return res;
        });
    }
    runMigrations(allScript, failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < allScript.length; i++) {
                yield this.runScript(allScript[i].name, allScript[i].created, failSilently);
            }
            this.logger.success('Migrations finished');
        });
    }
    markExecutedAll(allScript) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < allScript.length; i++) {
                yield this.markExecuted(allScript[i].name, allScript[i].created, null);
            }
            this.logger.info('All scripts has been marked as executed');
        });
    }
    getFailedMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const rows = yield this.readSql(this.driver.getFailedMigrations(), []);
            if (rows.length === 0) {
                this.logger.info('No failed migrations found');
            }
            else {
                this.logger.info(`Found ${rows.length} failed migrations, they will be flagged as resolved:`);
                let result = '';
                rows.forEach(e => {
                    result += ` - ${e.name}:\n   Error: ${e.error_if_happened}\n   Ran on: ${e.run_on}\n`;
                });
                this.logger.info(result);
            }
            return rows.length;
        });
    }
    resolveAllMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const found = yield this.getFailedMigrations();
            if (found) {
                yield this.runSql(this.driver.removeAllMigrations(), []);
                this.logger.info(`${found} migration(s) marked as resolved`);
            }
        });
    }
    run(command) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Running command ${command}`);
            const c = this.commands[command];
            if (c) {
                if (!c.skipInit) {
                    const inited = yield this.checkIfExists();
                    if (!inited) {
                        throw Error('Db is not initialized');
                    }
                }
                yield c.run();
            }
            else {
                this.printHelp();
                throw Error(`Invalid command ${command}`);
            }
        });
    }
    printHelp() {
        let des = '';
        Object.keys(this.commands).forEach(key => {
            des += `${this.logger.colors.FgCyan}${key}${this.logger.colors.Reset}: ${this.commands[key].description}\n`;
        });
        this.logger.info(`Available commands are: \n${des}`);
    }
    findAndRunMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const newMigrations = yield this.findNewMigrations(failSilently);
            this.printMigrations(newMigrations);
            yield this.runMigrations(newMigrations, failSilently);
        });
    }
    fakeAllScripts() {
        return __awaiter(this, void 0, void 0, function* () {
            const migrations = yield this.findNewMigrations(false);
            this.printMigrations(migrations);
            yield this.markExecutedAll(migrations);
        });
    }
    printMigrations(migrations) {
        if (migrations.length > 0) {
            this.logger.info(`New migrations found: \n  - ${migrations.map(e => e.name).join('\n  - ')}`);
        }
        else {
            this.logger.info('No new migrations are available');
        }
    }
    printNewMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.findNewMigrations(false);
            this.printMigrations(res);
        });
    }
}
exports.CommandsRunner = CommandsRunner;
//# sourceMappingURL=index.js.map